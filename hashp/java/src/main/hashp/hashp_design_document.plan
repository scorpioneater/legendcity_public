hashp - design document

     Copyright Michael Santa Cruz. All rights reserved.

Table of Contents

I.   Why Create a Hash-Based Language? An introduction and the Design Philosphy of hashp
II.  Perl, Python, Javascript, Clojure: Why the "100 Year" Languages Failed 
III. Keywords and built-in functions
IV:  Declaring custom functions


I. Why Create a Hash-Based Language? An introduction and the Design Philosphy of hashp
--------------------------------------------------------------------------------------------------------------------------------------------------
hashp is a functional/hash-based language that can simplify many tasks that require considerable boilerplate in the most commonly used languages. 
It takes getting used to: there are no free variables (only hash elements), you must create a hash that implements a single function just to do
basic arithmetic, and hashes were probably not your favorite subject in Data Structure 101.

However, hashes/maps/dictionaries are extremely useful in professional code. They are just inefficient from a memory-space standpoint, and in 
worst-case collision scenarios the performance can be O(n) or worse depending on the implementation.

So here is your first taste of hashp:

                >> hw ['Hello World!'] >> std_out

Ah, the famous "Hello World." The code above does what print("Hello World) does in other languages.  But it also does so much more. An explanation
of the symbols and elements of hashp Hello World:

1. >> functions as "main." It designates  that particular line (the PHash definition) as the program entry point.
2. "hw" is the PHash identifier, in this case short for "Hello World." The initial design of hashp will use 2 character identifiers, but this will 
be expaneded as the compiler/interpreter matures.
3. Square brackets mark the PHash body and all its child elements. 
4. 'Hello World' is enclosed in single quotes like a literal in other languaes. Sorry, in hashp there are no double quotes. Why do you really need 
    them if you are not manipulating bytes?
5. ">>" after the brackets directs the execution output to standard out.
6. std_out is the keyword for standard output. Notice that *nix conventions are used - capital letters are not allowed in identifier and keyword names. 

So you may be asking, "So when does it actually print anything?" The major goal of designing this language was to move as far away from the
procedural/limited OO paradigm that the top 5 languages inindustry use. Let's practice thinking in hashp, and thinking in hashes only. Let's add another 
line to the code above:

                   a0 ['Hasta Luego Mundo']
                >> hw [a(0)] >> std_out

The application now prints out a nice Spanish goodbye to our beloved world. a0 is another phash, but it is not the program entry point as indicated by 
the ">>." In this case it is purely a data structure, containing the single string as an element. Note that it can be accessed with the array conventions
of most procedural/OO languages. Drawing from JavaScript, we can use a key rather than the integer 0:

                   a0 [spanish:'Hasta Luego Mundo']
                >> hw [a(spanish)] >> std_out

Notice that while we only made a small cahnge to the code, we altered very little from the first example. This is another design goal of hashp - cut down
on the amount of code that has to be debugged, rewritten, or thrown away in refactoring efforts. The simplicity of hashp allows most of the scaffolding of
traditional programs to be folded into the basic syntax of the language.

II.  Perl, Python, Javascript, Clojure: Why the "100 Year" Languages Failed 

Y Combinator founder, Venture Capitalist, and Lisp hacker Paul Graham's essay "The Hundred-Year 
Language" is one of the best speculative pieces about the evolution of
languages in the 21st century and where they are going from C, C++, and
Java:

https://paulgraham.com/hundred.html

The TLDR version of this wonderful essay is that the languages gaining use 
and popularity in industry in 2025 are converging on the core principles of
List:

Interpteted
Functional


Perl:

Python:

Javascript:

Let's Pick on PHP While We're At It:

III.  Memory structure
--------------------------------------------------------------------------------------------------------------------------------------------------

Hashp is derived from languages that live using the stack/heap construct. In both C/C++ and Java, the stack and heap are separate areas of RAM in which the program's dynamic memory is allocated. The stack contains function calls and all local variables, and a "stack frame" only exists for the duration of a method call. Memory on the heap, however, is for objects created at runtime. Garbage collection and manual delation are the accepted methods for cleaning the heap.

It is important to note that the stack grows forward in terms of memory addresses, while the heap grows backwards.

-------------------------------|            |
|0x00| Stack                   |            |
|0x10|                         |            |
|0x20|                         |            |
|0x30|                         |            V
|0x40|                         |
|0x50|                         |  Direction of allocation relative to memory address
|------------------------------|
|0x60| Heap                    |            ^
|0x70|                         |            |
|0x80|                         |            |
|0x90|                         |            |
|0xA0|                         |            |
|0xB0|                         |
|------------------------------|
